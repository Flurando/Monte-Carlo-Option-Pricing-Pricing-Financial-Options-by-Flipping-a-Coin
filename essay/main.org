#+TITLE: 蒙特卡洛定价法简明介绍
#+AUTHOR: 
#+AFFILIATION: 深圳大学
#+DESCRIPTION: 关于欧洲看涨期权的定价问题，评估蒙特卡洛随机数法的优劣和适用性。
#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [a4paper,10pt]
#+LATEX_HEADER: \usepackage[margin=0.5in]{geometry}
#+LATEX_HEADER: \usepackage{xeCJK}
#+LATEX_HEADER: \usepackage{fontspec}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \setCJKmainfont{WenQuanYi Zen Hei}
#+OPTIONS: \n:t toc:nil num:nil date:nil

* 摘要
蒙特卡洛随机数法可以用于估算欧洲看涨期权的合理定价，这种通过一次次抛硬币模拟股价走向的方法，究竟是什么？它能让双方感到公平吗？
本文将基于《深圳大学高等数学2025年秋季微分方程研究项目》中关于蒙特卡洛问题的研究指导，一探究竟。
通过Guile Scheme语言编写模拟程序，发现在数量很多的情况下，单蒙特卡洛序列对最终定价的估算接近正态分布，而诸如合并相反走势的序列让结果更接近随机分布。
因此，在欧洲看涨期权的定价上，蒙特卡洛法是公平的，且比一次性从正态分布到随机分布之间的系数而言，体验更好。
* 引言
** 所用文档内容
#+begin_comment
此小节完全由人工智能AI翻译自question.org的background段，版权与question.org的background段相同。
如有出入，请参考纯手动转写的question.org。
使用的AI模型为GPT4o-mini，由Duck.ai(Free)提供。
输入的Prompt为question.org的background内容加“翻译成一篇中文引言”。
#+end_comment
在金融市场中，股票价格的变化受到多种因素的影响，而建模这种变化对于理解和预测市场动态至关重要。《深圳大学高等数学2025年秋季微分方程研究项目》介绍了蒙特卡洛方法，用于在时间区间 \([0, T]\) 上模拟股票价格的变化。该模型由以下差分方程描述：
\begin{equation}
S_{n+1} = S_n + \mu S_n \Delta t + \delta S_n \epsilon_{n+1} \sqrt{\Delta t}, \quad S_0 = s
\end{equation}
其中，\(S_n\) 表示在时间 \(t_n = n\Delta t\) 时的股票价格，\(\mu\) 是年增长率，而 \(\delta\) 则表示股票价格波动性的度量。高波动性的股票通常具有较大的 \(\delta\) 值，范围从 0.2 到 0.4。在模型中，\(\epsilon_n\) 是一序列随机变量，其取值为 1 或 -1，依赖于抛硬币实验的结果。
通过利用这一差分方程，可以模拟出股票价格的样本路径，即 \(\{s,S_1,S_2,\dots,S_N\}\)。其中，方程右侧的随机项 \(\delta S_n \epsilon_{n+1} \sqrt{\Delta t}\) 可以视为模拟股票价格波动的“冲击”或“干扰”。反复模拟股票价格轨迹并计算适当的平均值，可以获得对欧洲股票看涨期权（European call option）价格的估计，这类金融衍生品在市场中广泛应用。
欧洲看涨期权是一种合同，双方为拥有者和期权卖方，支付给期权卖方的溢价换取在未来某一日期 \(T\) 以约定价格 \(K\) 购买股票的权利。如果买方选择在到期日行使期权，期权卖方则必须以价格 \(K\) 向买方出售基础股票。该期权的收益函数定义为：
\begin{equation}
f(S) = \text{max}(S - K,0)
\end{equation}
其中 \(S = S(T)\) 是到期时基础股票的价格。此收益函数反映了如果 \(S(T) > K\)，持有人可以以价格 \(K\) 购买市值为 \(S(T)\) 的股票，从而获取相应的利润。而当 \(S(T) < K\) 时，持有人就会选择不行使期权，因为以超过市场价值的价格购得股票是不理智的。
期权定价问题的核心在于确定持有人和期权卖方在合同签订时所应支付的公允价格。通过蒙特卡洛方法，我们生成一个由 \(M\) 个到期时股票价格组成的集合：
\begin{equation}
\left\{S_N^{(k)} = S^{(k)}(T), k = 1, \dots, M\right\}
\end{equation}
此集合通过差分方程进行生成，其中增长率 \(\mu\) 被替换为期权卖方借款的年利率 \(r\)：
\begin{equation}
S_{n+1}^{(k)} = S_n^{(k)} + r S_n^{(k)} \Delta t + \delta S_n^{(k)} \epsilon_{n+1}^{(k)} \sqrt{\Delta t}, \quad S_0^{(k)} = s
\end{equation}
期权定价理论要求期权收益的平均值等于选项溢价在期权有效期内复利所获得的总回报。由此形成的关系为：
\begin{equation}
\frac{1}{M}\sum_{k=1}^M f(S_N^{(k)}) = (1 + r \Delta t)^N \mathring{C}(s)
\end{equation}
解出 \(\mathring{C}(s)\) 得到蒙特卡洛估计：
\begin{equation}
\mathring{C}(s) = (1 + r \Delta t)^{-N} \left\{\frac{1}{M}\sum_{k=1}^M f(S_N^{(k)})\right\}
\end{equation}
此时，蒙特卡洛估计 \(\mathring{C}(s)\) 是对通过复利规则计算的平均收益的现值估计。通过这样的建模与模拟，可以有效评估股票期权的市场价值，以及理解市场中潜在的风险和收益。
** 本文解决的问题
原文档只给出了数学公式及含义，没有可以用于实验的代码，或者JupyterNotebook之类的展示。并且缺少评估。
本文给出使用可运行的Guile Scheme代码，只需要很少的依赖（guile3.0.9和仅作图需要的guile-plotutils1.0.1）便可完整运行所有代码，并对实验示例结果作出评估。
** 重要性
虽然在欧洲看涨期权的定价方面有很多模型，但是作为投资者在不理解模型原理和可能结果的情况下盲目相信，是不妥当的。
跟随本文并用提供的代码进行实验，人们可以理解蒙特卡洛法为什么公平，以及结果的分布，在协商估算模型的使用时可以更高效快速的达成一致。
蒙特卡洛模型虽然不是被撰写本文的当下认为是最准确的（相比之下Black Scholar更被人们推崇），但它是最好验证的，即便没有相关数学知识。
另外，与多数相关文章不同，我没有引用任何Python库，然后一行代码了事，而是完整的无任何强制性外部依赖的Guile Scheme实现，方便人们去验证，检查，学习。
如果你不需要画图，那么一个Guile解释器够了，仅在需要画图功能的情况下需要Gnu Plotutils和相关的guile-plotutils。
同时，本文应用了实验性的Guix包管理器作为可复现代码运行环境搭建工具，加上所研究的问题及内容相对简单基础，可以作为一个可复现研究的示例。
* 文献综述
** 欧洲看涨期权
欧洲看涨期权是一种类似对赌协议的合同，通过提前付一笔钱换取一定期限内用协商好的价格购买一定数目股票的权利。
显而易见，如果市场价比协商好的高，投资方就赚了，如果市场价比协商好的低，投资方通常就放弃买入，亏预付的那笔钱。
对于股票发行方来说，他可以提前得到一笔钱启动项目，而不是必须做出成品才能进入市场，代价是可能得到的总金额更少。
** 布朗运动
没有看错，是布朗运动，但不是中学阶段教授的花粉在水面上运动。
这里说的布朗运动是用于价格估算的随机模型，作为蒙特卡洛法以及Black Scholar方法的基础。
也就是我们要探讨的蒙特卡洛方法是直接假设市场资产价格按照布朗运动描述的那样随机变化。
简单来说，就是价格和时间的平方根成正比，这也是为什么蒙特卡洛方法的递推式中抖动项会用 $\sqrt{\Delta t}$
** 蒙特卡洛方法
假设未来股票的涨跌不是被人为操纵的，项目的自然趋势也是完全未知的，那么可以认为每一小段时间内是涨是跌可能性相等。
同时为了简单，在复利计算下涨跌的幅度是固定的，如要么涨5%，要么跌5%。
接着再假定一个初始的股价，这个是可以决定的，那么计算出一个序列，就可以模拟出任意时间的股价。
通过多次模拟股价的平均，就可以得到一个理论上对发行方和投资方公平的期权价格。
在这个价格下，投资方亏/赚的期望相等，发行方也是。
** Black Scholar方法
又称BSM法，直接从类似正态分布的地方计算出期望，由于蒙特卡洛方法在量足够大时分布也趋近于Black Scholar的结果，因此一般认为Black Scholar更加实用，只要双方相信其数学机理。
** Guile Scheme
带自动垃圾回收的编程语言之一，是Scheme的Guile实现。
语法非常简单，如果使用者用Wisp来编写或者不介意Lisp系语言的满屏圆括号的话。
** Guix
没有Nix的Nix，和Nix构造类似，但是不使用Nix的配置格式，而是用Guile Scheme来配置。
相比之下，原本在Nix中的配置文件，变成了一个个Guile Scheme程序，功能更加灵活，可拓展性更好。
* 方法
值得注意的是，如果不考虑 $\delta$ 抖动，即 $\delta=0$ 那么递推式为 $S_{n+1} = S_n + \mu S_n \Delta t, S_0=s$。
这就是理想的复利计算，年利率为 $\mu$，等式如下
\begin{equation*}
\frac{dS}{dt}=\mu S
\end{equation*}
对这个式子用欧拉方法，假设 $n=0,1,\dots$, 步长为 $\Delta t$，可以得到
$$\begin{aligned}
S_{n+1} &= S_n + \left.\frac{dS}{dt}\right|_{t_n} S_n \Delta t\\
&= S_n + \mu S_n \Delta t
\end{aligned}$$
也就是说，蒙特卡洛方法其实是模拟了会抖动的复利。
接下来就是按给定的参数计算一定时间内最终价格，因此如果我们要估计总时间 $T$（单位：年）时的价格，就要 $n\cdot \Delta t = T$。
这里 $n$ 和 $\Delta t$ 具体取值任意，当然我们一般要用一个“足够小”的 $\Delta t$，这是微积分的原则，$\Delta t$ 越小越精确，代价是计算量更大。
首先，使用参数 $\mu = 0.12, T = 1, s = \textdollar 40, N = 254$ 分别对 $\delta=0.1$ 和 $\delta=0.25$ 进行五次模拟
并分别在同一张图里作出连续时间内股价的五条走势线
接着计算 $M$ 次 $5$ 个月时示例参数的估算股价并取平均，同时对三个不同的初始价格进行运算，结果分别与Black Scholar的结果进行比较。值得注意的是，此处使用的erfc实现据称只有 $10^{-7}$ 精确度。
最后尝试使用另一种蒙特卡洛方法，将两个走势完全相反，即每个 $\epsilon$ 互为相反数的估算合并取平均，并和原本的单序列估算分布进行比较。

* 结果
某次五次模拟运行结果如下
[[../code/images/q2-delta-0.1.png]]
和
[[../code/images/q2-delta-0.25.png]]
注意，由于随机数种子不是固定的，所以此结果无法100%复现。
从 $y$ 轴坐标可以看到，$\delta$ 越大，股价波动范围就越大，与常识相符。
在估算三个不同初始价格五个月后的股价时，输出如下
#+begin_src text
  Case s = 45
  After 10000 rounds
  Morte Carlo: 0.9513261102990752
  Compared to Black Scholes formula result
  Black Scholes: 0.9821994485439998
  The percentage error taking BSM as reference is: 3.1432860495585504%
  Case s = 50
  After 10000 rounds
  Morte Carlo: 3.103107411043916
  Compared to Black Scholes formula result
  Black Scholes: 3.206291004696837
  The percentage error taking BSM as reference is: 3.218160594336862%
  Case s = 55
  After 10000 rounds
  Morte Carlo: 6.902299776628594
  Compared to Black Scholes formula result
  Black Scholes: 6.866778428333703
  The percentage error taking BSM as reference is: 0.5172927693184718%
#+end_src
可以看到，绝对误差与BSM相差无几，相对误差由于数值本身就很小所以在初始价格低时较大。
#+begin_src text
  new way using ({}+{})/2
  for 20 rounds:
  (0.4867603410369392 0.5088339539060607 0.515927314555167 0.5176025238461435 0.5010024984596436 0.46976928054438993 0.5179985617714127 0.4999120304610847 0.49052173689600614 0.5177035032924415 0.5260035920302344 0.4820877221086515 0.4938067826514226 0.5058316562711163 0.5074331713671288 0.5145855911714374 0.5205604281511415 0.48756460911085314 0.5028267327886505 0.5018259638146649)
  mean: 0.5034278997117294
  standard-derivation: 0.01440493199980871
  old way using {}
  for 20 rounds:
  (0.981504148749321 0.9953873985693401 0.9820923852998381 1.0199137716414859 0.960279163391967 0.9869349876499919 1.021648334969107 1.0351389642178677 0.9607247121539174 1.0064387855231078 1.0135633288739987 0.9441738640632169 1.026486055935382 0.9933444348797862 1.003906745878322 0.9862526844981201 1.0002957376642247 1.0013558229891704 1.0029814726408437 1.0386240040563919)
  mean: 0.9980523401822701
  standard-derivation: 0.02428353124392
  Rearrange
  the new method:
  0.46976928054438993<={}<0.47780275361379626: 1
  0.47780275361379626<={}<0.48583622668320264: 1
  0.48583622668320264<={}<0.49386969975260897: 4
  0.49386969975260897<={}<0.5019031728220154: 3
  0.5019031728220154<={}<0.5099366458914217: 4
  0.5099366458914217<={}<0.517970118960828: 4
  0.517970118960828<={}<0.5260035920302344: 2
  outage: 1
  Histogram:
  0.46976928054438993<={}<0.47780275361379626
  | *****
  0.47780275361379626<={}<0.48583622668320264
  | *****
  0.48583622668320264<={}<0.49386969975260897
  | ********************
  0.49386969975260897<={}<0.5019031728220154
  | ***************
  0.5019031728220154<={}<0.5099366458914217
  | ********************
  0.5099366458914217<={}<0.517970118960828
  | ********************
  0.517970118960828<={}<0.5260035920302344
  | **********
  outage:
  | *****
  the old method:
  0.9441738640632169<={}<0.9576667412050991: 1
  0.9576667412050991<={}<0.9711596183469812: 2
  0.9711596183469812<={}<0.9846524954888634: 2
  0.9846524954888634<={}<0.9981453726307454: 4
  0.9981453726307454<={}<1.0116382497726275: 5
  1.0116382497726275<={}<1.0251311269145098: 3
  1.0251311269145098<={}<1.0386240040563919: 2
  outage: 1
  Histogram:
  0.9441738640632169<={}<0.9576667412050991
  | *****
  0.9576667412050991<={}<0.9711596183469812
  | **********
  0.9711596183469812<={}<0.9846524954888634
  | **********
  0.9846524954888634<={}<0.9981453726307454
  | ********************
  0.9981453726307454<={}<1.0116382497726275
  | *************************
  1.0116382497726275<={}<1.0251311269145098
  | ***************
  1.0251311269145098<={}<1.0386240040563919
  | **********
  outage:
  | *****
#+end_src
可以看到，整合互补序列会导致分布更均匀分散，而单个序列呈现出类似正态分布的结果。

* 讨论
** 为什么蒙特卡洛法是公平的？
蒙特卡洛法基于描述资产价格随机变化的布朗运动模型，在复利计算基础上引入与单位时间开根号成正比的随机涨跌，只要大量模拟计算取平均，就能无限接近真实利率。这种随机序列模拟便于理解，通用于很多复杂的估算，在其他领域或Black Scholar等替代算法不被双方承认的情况下可以足够好的保证公平。
** 多个序列组合作为一次估算好还是单个序列出结果好？
多个涨跌趋势互补或部分互补的序列组合会导致分布从正态转向随机，这个程度应当由合约双方商议决定，但不用担心的是，无论如何生成，期望都是相同的，也就是都公平。没有具体问题和现实情况（如市场并不完全遵守布朗运动），这两者并没有好坏之分。
** 本文提及的代码可以用于实践吗？
不建议，首先本文提及的代码除非特殊标注，都是GPLv3+开源，其次，本文使用的是私有实现，部分关键如Black Scholar使用的erfc函数，未经验证照搬StackOverflow内容，正确性有待考量。除却学习、兴趣之外，不应该使用私有实现，因为一切生产后果概不负责。
* 结论
蒙特卡洛方法很有效、公平的估算理想随机状态下欧洲看涨期权的公认价格。
本文通过一系列可复现的代码实验，展示了蒙特卡洛方法可能的应用方式，并与被公认更贴切高效的Black Scholar方法进行了对比。
* 参考文献
** 文献
仅《深圳大学高等数学2025年秋季微分方程研究项目》，内部资料，我不清楚版权所以不能公开。对本文涉及的问题请参考库里的question.org文件。
** 查阅
stackoverflow上关于erfc的无依赖实现。
* 附录
本文所述的内容，包括问题、本文本身以及可运行的代码等，均在GitHub上。
若无法访问GitHub请前往[[https://archive.softwareheritage.org/swh:1:dir:26448319be70d603c80c30da97f7bf014dad3354;origin=https://github.com/Flurando/Monte-Carlo-Option-Pricing-Pricing-Financial-Options-by-Flipping-a-Coin;visit=swh:1:snp:bc6b22d633b062b659e3b56b7afd95ddacb7d9c3;anchor=swh:1:rev:578d0a70f1b428854cd42b987dc616efc281b186][SWH]]查看，对应的identifier是
#+begin_comment
由于SWH得先存档才生成标识，所以此处的identifier其实指向的是老版本。
#+end_comment
:identifier:
swh:1:dir:edb8c639f79c7e2bc3f85dd9568827dffc1f509e;
origin=https://github.com/Flurando/Monte-Carlo-Option-Pricing-Pricing-Financial-Options-by-Flipping-a-Coin;
visit=swh:1:snp:3593c4d586261706b19049da49c740c07901b076;
anchor=swh:1:rev:201b424cf51b9245379573ff4712bd95bceaf1e6
:end:
使用方法详见库的子文件夹内README文件。
